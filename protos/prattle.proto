syntax = "proto3";

import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";

option go_package = "github.com/prattle-chat/prattle-proxy/server";


// Proxy handles the proxying and routing of chat messages between parties
// including to parties on other prattle servers.
//
// Authentication is done through bearer tokens, which are time-limited and
// minted through calls to Proxy.Token.
//
// IDs are minted through a two part call to 'Proxy.Signup' and 'Proxy.Finalise'
// which mint an ID and an OTP seed (before validating that seed in Finalise)
//
// A user subscribes to a proxy instance via Proxy.Subscribe by authenticating
// with their bearer token. This token is used to retrieve a user's ID
service Proxy {
  // Signup accepts a new password and mints a new ID and OTP seed
  rpc Signup(SignupRequest) returns (SignupResponse) {}

  // Finalise is used to finalise the signup flow, which it does by accepting
  // the minted ID and a valid OTP value.
  //
  // This call will return an error or nothing
  rpc Finalise(Auth) returns (google.protobuf.Empty) {}

  // Token accepts a password and a valid OTP value, returning a new bearer
  // token which can be used in Subscribing to message stream
  rpc Token(Auth) returns (TokenValue) {}

  // AddPublicKey adds a new public key for a user. A user can have up to n public
  // keys, where n is configured on the proxy.
  //
  // Where n is too few, a user is limited by the number of clients they can connect
  // with.
  // Where n is too high, the cost of sending a user a message becomes high, as does
  // receiving _for_ that user
  rpc AddPublicKey(PublicKeyValue) returns (google.protobuf.Empty) {}

  // Subscribe is used to provide a stream to receive a user's messages
  rpc Subscribe(google.protobuf.Empty) returns (stream MessageWrapper) {}

  // PublicKey retrieves the public keys of a user, handling cases where a key
  // lives on a third-party proxy instance
  rpc PublicKey(Auth) returns (stream PublicKeyValue) {}

  // Send accepts an encoded/ wrapped message and sends it to a user
  rpc Send(MessageWrapper) returns (google.protobuf.Empty) {}

  /**
     The following calls govern access to groups in prattle.

     Groups are essentially lists of users.
     A group can be open or not; an open group allows anybody to join,
     whereas a closed group requires explicit invitation

     A group can also be a broadcast group, which means only owners can
     send messages
  **/

  // CreateGroup will create a group, setting the calling user as owner
  rpc CreateGroup(Group) returns (Group) {}

  // JoinGroup will join the calling user to a group, so long as that
  // group is set to Open
  rpc JoinGroup(Group) returns (google.protobuf.Empty) {}

  // Group returns information about a group, such as owners and members
  rpc GroupInfo(Group) returns (Group) {}

  // InviteToGroup allows group owners to invite users to a group
  rpc InviteToGroup(GroupUser) returns (google.protobuf.Empty) {}

  // PromoteUser allows a group owner to make another user an owner
  rpc PromoteUser(GroupUser) returns (google.protobuf.Empty) {}

  // DemoteUser allows a group owner to demote another owner to
  // regular user, or to boot a regular user from the group
  rpc DemoteUser(GroupUser) returns (google.protobuf.Empty) {}

  // LeaveGroup allows a user to leave a group
  rpc LeaveGroup(Group) returns (google.protobuf.Empty) {}
}


// SignupRequest contains a password to be used during Signup
//
// This message could be merged with OTPAndKey, but it makes a certain
// amount of sense to keep this small, explicit, and less complex by
// making it only used in a single place
message SignupRequest {
  string password = 1;
}

// SignupResponse contains the information necessary to connect to a Proxy;
// namely: the user's new ID (including domain name information), and a
// value which can seed an OTP app/authenticator/etc. to act as a password.
message SignupResponse {
  string user_id = 1;
  string totp_seed = 2;
}

// Auth encapsulates the information necessary to authenticate,
// specifically:
//
//   1. User ID
//   2. Password
//   3. TOTP value
//
// and is used in a number of places:
//
//   1. To finalise signup; and
//   2. To receive a new session token
message Auth {
  string user_id = 1;
  string password = 2;
  string totp = 3;
}

// PublicKey contains data associated with Public Keys
message PublicKeyValue {
  string value = 1;
}

// Token contains a session token, used during Subscribe, Send,
// and public key operations
message TokenValue {
  string value = 1;
}

// MessageWrappper wraps an encoded/ encrypted message to be forwarded to a recipient
//
// Encoded is expected to be formed by taking a 'Message' and encypting it with the
// recipient's public key. Because of this, that message is where all of the important
// and useful metadatas are stored, such as sender
message MessageWrapper {
  string recipient = 1;
  bytes encoded = 2;
}

message Message {
  // recipient in this context is used to determine whether a message was sent to a
  // user directly, or to a group
  string recipient = 1;
  string sender = 2;
  google.protobuf.Timestamp datetime = 3;
  bytes body = 4;
}

// Group is used for most group operations, such as:
//
//   1. Creating a group (note: ID is ignored; IDs are generated)
//   2. Joining groups (note: anything _but_ ID is ignored here;
//      this call fills out missing data in the message and returns it)
//   3. Viewing group info (note: works the same as Joining)
message Group {
  string id = 1;
  repeated string owners = 2;
  repeated string members = 3;
  bool is_open = 4;
  bool is_broadcast = 5;
}

// GroupUser is used on operations where a group ID and a user ID
// is needed, such as invitations, booting users, etc.
message GroupUser {
  string group_id = 1;
  string user_id = 2 ;
}

/*

  Signup flow:
  1. Send a request to 'Proxy.Signup' containing a password, returning a seed for OTP and a new ID
  2. Send a request to 'Proxy.Finalise' containing an OTP

  Login flow:
  1. Send a request to 'Proxy.Token' containing an OTP and a password, receiving a token (these are valid for a set period of time before re-negotiation is needed)
  2. This request should block for an amount of time in the expectation that this will slow down/ discourage attackers
  3. On many failures, block login for an amount of time


 */
